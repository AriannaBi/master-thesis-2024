

mod gen_mutation_CTL is
   sort Formula .

--- atomic propositions
   op a : -> Formula .
   --- ops a "b" "c" "d" "e" "f" true false : -> Formula .
   --- ops s=0 s=1 s=2 s=3 s=4 s=5 s=6 : -> Formula .
   --- ops s~=0 s~=1 s~=2 s~=3 s~=4 s~=5 s~=6 : -> Formula .

--- operators
   op X : Formula -> Formula . ---    neXt
   op ~ : Formula -> Formula . ---    not
   op F : Formula -> Formula . ---    eventually
   op G : Formula -> Formula . ---    always
   op (_)^(_) : Formula Formula -> Formula . ---    and
   op (_)v(_) : Formula Formula -> Formula . ---    or
   op (_)U(_) : Formula Formula -> Formula . ---    until
   op _=>_ : Formula Formula -> Formula . ---    implication
   op _<=>_ : Formula Formula -> Formula . ---    implication

   --- CTL
   op AX(_) : Formula -> Formula . ---    path quantifier
   op AG(_) : Formula -> Formula . ---    path quantifier
   op AF(_) : Formula -> Formula . ---    path quantifier
   op A((_)U(_)) : Formula Formula -> Formula . ---    path quantifier
   
   op EX(_) : Formula -> Formula . ---    path quantifier
   op EG(_) : Formula -> Formula . ---    path quantifier
   op EF(_) : Formula -> Formula . ---    path quantifier
   op E((_)U(_)) : Formula Formula -> Formula . ---    path quantifier

--- variables
   vars N M P : Formula .

********************************* rules **********************************************
   rl [try] : ~(AF (M)) => EX (~(M)) .
   rl [duality1] : AX (M) => ~(EX(~(M))) .
   rl [duality2] : AF (M) => ~(EG(~(M))) .
   rl [duality3] : EX (M) => ~(AX(~(M))) .
   rl [duality4] : EF (M) => ~(AG(~(M))) .
   rl [duality5] :  A ((M)U(N)) => (~(E ((~(N)) U (((~(M)) ^ (~(N))))))) ^ (~(EG(~(N)))).
   --- rl [duality5] :  A (M) U (N) => (~(E((M) ^ (~(N))) U ((~(N)) ^ (~(M))))) ^ (~(EG((M) ^ (~(N))))) .
   
   --- rl [expansion1] : A[(M) U (N)] => (N) v ((M) ^ (A[X(A[(M) U (N)])])) .
   --- rl [expansion2] : A[F(M)] => (M) v (A[X(A[F(M)])]) .
   --- rl [expansion3] : A[G(M)] => (M) ^ (A[X(A[G(M)])]) .


   --- rl [distributive1] : A[G((M) ^ (N))] => (A[G(M)]) ^ (A[G(N)]) .
   --- rl [distributive2] : E[F((M) ^ (N))] => (E[F(M)]) v (E[F(N)]) .


--- ******************************* end rules *******************************************
   --- rl [duality1_reverse] : ~(E[X(~(M))]) => A[X(M)] .
   --- rl [duality2_reverse] : ~(E[G(~(M))]) => A[F(M)] .
   --- rl [duality3_reverse] : ~(A[X(~(M))]) => E[X(M)] .
   --- rl [duality4_reverse] : (~(E[(~(N)) U (((~(M)) ^ (~(N))))])) ^ (~(E[G(~(N))])) => A[(M) U (N)] .
   --- rl [duality5_reverse] : (~(E[((M) ^ (~(N))) U ((~(N)) ^ (~(M)))])) ^ (~(E[G((M) ^ (~(N)))])) => A[(M) U (N)] .

   --- rl [expansion1_reverse] : (N) v ((M) ^ (A[X(A[(M) U (N)])])) => A[(M) U (N)] .
   --- rl [expansion2_reverse] : (M) v (A[X(A[F(M)])]) => A[F(M)] .
   --- rl [expansion3_reverse] : (M) ^ (A[X(A[G(M)])]) => A[G(M)] .

   --- rl [distributive1_reverse] : (A[G(M)]) ^ (A[G(N)]) => A[G((M) ^ (N))] .
   --- rl [distributive2_reverse] : (E[F(M)]) v (E[F(N)]) => E[F((M) ^ (N))] .

********************************* rules_reversed **********************************************
    
******************************* end rules_reversed *******************************************



--- ./ctl-sat "~(((AF(a)) -> (AF(a))) ^ ((AF(a)) -> (AF(a))))"

endm