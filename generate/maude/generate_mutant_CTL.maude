mod gen_mutation_CTL is
   sort Formula .
   ops a b c : -> Formula .

   

--- operators
   op X : Formula -> Formula . ---    neXt
   op ~ : Formula -> Formula . ---    not
   op F : Formula -> Formula . ---    eventually
   op G : Formula -> Formula . ---    always
   op (_)^(_) : Formula Formula -> Formula . ---    and
   op (_)v(_) : Formula Formula -> Formula . ---    or
   op (_)U(_) : Formula Formula -> Formula . ---    until
   op _=>_ : Formula Formula -> Formula . ---    implication
   op _<=>_ : Formula Formula -> Formula . ---    implication

   --- CTL
   op AX(_) : Formula -> Formula . ---    path quantifier
   op AG(_) : Formula -> Formula . ---    path quantifier
   op AF(_) : Formula -> Formula . ---    path quantifier
   op A((_)U(_)) : Formula Formula -> Formula . ---    path quantifier
   
   op EX(_) : Formula -> Formula . ---    path quantifier
   op EG(_) : Formula -> Formula . ---    path quantifier
   op EF(_) : Formula -> Formula . ---    path quantifier
   op E((_)U(_)) : Formula Formula -> Formula . ---    path quantifier

--- variables
   vars N M P : Formula .

********************************* rules **********************************************
   rl [paper] : ~(AF (M)) => EG (~(M)) .
   rl [duality1] : AX (M) => ~(EX(~(M))) .
   rl [duality2] : AF (M) => ~(EG(~(M))) .
   rl [duality3] : EX (M) => ~(AX(~(M))) .
   rl [duality4] : EF (M) => ~(AG(~(M))) .
   rl [duality5] :  A ((M)U(N)) => (~(E ((~(N)) U (((~(M)) ^ (~(N))))))) ^ (~(EG(~(N)))) .
   rl [duality6] :  A ((M)U(N)) =>  (~(E (((M) ^ (~(N))) U ((~(M)) ^ (~(N)))))) ^ (~(EG ((M) ^ (~(N))))) .
   
   rl [distributive1] : AG ((M) ^ (N)) => (AG(M)) ^ (AG(N)) .
   rl [distributive2] : EG ((M) v (N)) => (EF(M)) v (EF(N)) .

   rl [expansion_law1] : A ((M) U (N)) => (N) v ((M) ^ (AX(A((M) U (N))))) .
   --- rl [expansion_law2] : AF(M) => (M) v (AX(AF(M))) .
   rl [expansion_law3] : AG(M) => (M) ^ (AX(AG(M))) .

   rl [expansion_law4] : E ((M) U (N)) => (N) v ((M) ^ (EX(E((M) U (N))))) .
   rl [expansion_law5] : EF(M) => (M) v (EX(EF(M))) .
   --- rl [expansion_law6] : EG(M) => (M) ^ (EX(EG(M))) .

   ******************************* end rules *******************************************
   
   ********************************* rules_reversed **********************************************
   rl [paper_reverse] : EG (~(M)) => ~(AF (M)) .
   rl [duality1_reverse] : ~(EX(~(M))) => AX (M) .
   rl [duality2_reverse] :  ~(EG(~(M))) => AF (M) .
   rl [duality3_reverse] :  ~(AX(~(M))) => EX (M) .
   rl [duality4_reverse] :  ~(AG(~(M))) => EF (M) .
   rl [duality5_reverse] :   (~(E ((~(N)) U (((~(M)) ^ (~(N))))))) ^ (~(EG(~(N)))) => A ((M)U(N)) .
   rl [duality6_reverse] :    (~(E (((M) ^ (~(N))) U ((~(M)) ^ (~(N)))))) ^ (~(EG ((M) ^ (~(N))))) => A ((M)U(N)) .
   
   rl [distributive1_reverse] :  (AG(M)) ^ (AG(N)) => AG ((M) ^ (N)) .
   rl [distributive2_reverse] :  (EF(M)) v (EF(N)) => EG ((M) v (N)) .

   rl [expansion_law1_reverse] :  (N) v ((M) ^ (AX(A((M) U (N))))) => A ((M) U (N)) .
   --- rl [expansion_law2_reverse] : (M) v (AX(AF(M))) => AF(M) .
   rl [expansion_law3_reverse] :  (M) ^ (AX(AG(M))) => AG(M) .

   rl [expansion_law4_reverse] :  (N) v ((M) ^ (EX(E((M) U (N))))) => E ((M) U (N)) .
   rl [expansion_law5_reverse] :  (M) v (EX(EF(M))) => EF(M) .
   --- rl [expansion_law6_reverse] : (M) ^ (EX(EG(M))) => EG(M) .
   ******************************* end rules_reversed *******************************************








   --- rl [expansion1] : A[(M) U (N)] => (N) v ((M) ^ (A[X(A[(M) U (N)])])) .
   --- rl [expansion2] : A[F(M)] => (M) v (A[X(A[F(M)])]) .
   --- rl [expansion3] : A[G(M)] => (M) ^ (A[X(A[G(M)])]) .


   --- rl [distributive1] : A[G((M) ^ (N))] => (A[G(M)]) ^ (A[G(N)]) .
   --- rl [distributive2] : E[F((M) ^ (N))] => (E[F(M)]) v (E[F(N)]) .


--- ******************************* end rules *******************************************


--- ./ctl-sat "~(((AF(a)) -> (AF(a))) ^ ((AF(a)) -> (AF(a))))"

endm
